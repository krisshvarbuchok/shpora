
const UseCallback = () => {

    return (
        <>
            <div className="text-blok">
                <h1><strong>useCallback</strong></h1>
                <ul>Хук useCallback принимает два параметра:
                    <li>1. <strong>Callback-функция:</strong> Это <strong>функция</strong> , которую мы хотим <strong>мемоизировать</strong>, когда этот <strong>сallback вызывается,</strong> useCallback возвращает эту же функцию, если зависимости не изменились.</li>
                    <li>2. <strong>Массив зависимостей:</strong> Это массив значений, от которых зависит сallback-функция. Если хотя бы одно из значений в массиве изменится, хук useCallback вернет новую мемоизированную версию колбэка. Если массив пустой, то колбэк будет создан только один раз, при первом рендере компонента.</li>
                </ul>
            </div>
            <div className="code-blok">
                <pre>
                    <code>{
`//useCallback создает мемоизированную версию функции doSomething
//эта версия будет обновляться только в случае изменения значений a или b
const memoizedCallback = useCallback(
  () => doSomething(a, b),
  [a, b],
);`
                        }</code>
                </pre>
            </div>
            <div className="text-blok">
                <p>Предотвращает создание новых функций при каждом рендере, если зависимости не изменились. Это особенно полезно, когда вы передаете функции как пропсы к дочерним компонентам или используете их в useEffect или useMemo.</p>
                <p><strong>Когда использовать useCallback:</strong></p>
                <ul>
                    <li><strong>Передача функций как пропсов:</strong> Если вы передаете функции в дочерние компоненты, использование useCallback предотвращает ненужные перерендеры дочерних компонентов.</li>
                    <li><strong>Использование в useEffect:</strong> Если функция используется в качестве зависимости для useEffect, useCallback гарантирует, что useEffect будет запускаться только тогда, когда функция изменяется.</li>
                    <li><strong>Оптимизация производительности:</strong> В случаях, когда функции используются в большом количестве рендеров, использование useCallback может уменьшить количество создаваемых новых функций, тем самым улучшая производительность.</li>
                    
                </ul>
            </div>
        </>
    )
}
export default UseCallback;